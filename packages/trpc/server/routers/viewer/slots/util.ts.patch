<<<<
    const hosts = await this.calculateHostsAndAvailabilities({
      eventType,
      dateFrom,
      dateTo,
      timeZone,
      rescheduleUid,
      isTeamEvent,
    });
====
    // New logic to fetch guest availability during reschedule
    let guestBusyTimes: EventBusyDetails[] = [];
    if (rescheduleUid) {
      try {
        const originalBooking = await this.bookingRepository.findOriginalRescheduledBooking(rescheduleUid);
        if (originalBooking && originalBooking.attendees[0]) {
          const guestEmail = originalBooking.attendees[0].email;
          const guestUser = await this.userRepository.findByEmail(guestEmail);
          if (guestUser) {
            const guestCredentials = await this.userRepository.findByIdWithCredentialsAndCalendar(guestUser.id);
            if (guestCredentials && guestCredentials.credentials.length > 0) {
              guestBusyTimes = await getBusyCalendarTimes(
                guestCredentials.credentials,
                dateFrom,
                dateTo,
                guestUser.timeZone
              );
            }
          }
        }
      } catch (e) {
        log.error("Failed to fetch guest availability", e);
      }
    }

    const hosts = await this.calculateHostsAndAvailabilities({
      eventType,
      dateFrom,
      dateTo,
      timeZone,
      rescheduleUid,
      isTeamEvent,
      guestBusyTimes, // Pass guest busy times to host calculation
    });
>>>>
