/* !!! This is code generated by Prisma. Do not edit directly. !!! */

/* eslint-disable */
// @ts-nocheck

/*
 * This file exports the `Watchlist` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";

import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Watchlist
 *
 */
export type WatchlistModel = runtime.Types.Result.DefaultSelection<Prisma.$WatchlistPayload>;

export type AggregateWatchlist = {
  _count: WatchlistCountAggregateOutputType | null;
  _avg: WatchlistAvgAggregateOutputType | null;
  _sum: WatchlistSumAggregateOutputType | null;
  _min: WatchlistMinAggregateOutputType | null;
  _max: WatchlistMaxAggregateOutputType | null;
};

export type WatchlistAvgAggregateOutputType = {
  organizationId: number | null;
};

export type WatchlistSumAggregateOutputType = {
  organizationId: number | null;
};

export type WatchlistMinAggregateOutputType = {
  id: string | null;
  type: $Enums.WatchlistType | null;
  value: string | null;
  description: string | null;
  isGlobal: boolean | null;
  organizationId: number | null;
  action: $Enums.WatchlistAction | null;
  source: $Enums.WatchlistSource | null;
  lastUpdatedAt: Date | null;
};

export type WatchlistMaxAggregateOutputType = {
  id: string | null;
  type: $Enums.WatchlistType | null;
  value: string | null;
  description: string | null;
  isGlobal: boolean | null;
  organizationId: number | null;
  action: $Enums.WatchlistAction | null;
  source: $Enums.WatchlistSource | null;
  lastUpdatedAt: Date | null;
};

export type WatchlistCountAggregateOutputType = {
  id: number;
  type: number;
  value: number;
  description: number;
  isGlobal: number;
  organizationId: number;
  action: number;
  source: number;
  lastUpdatedAt: number;
  _all: number;
};

export type WatchlistAvgAggregateInputType = {
  organizationId?: true;
};

export type WatchlistSumAggregateInputType = {
  organizationId?: true;
};

export type WatchlistMinAggregateInputType = {
  id?: true;
  type?: true;
  value?: true;
  description?: true;
  isGlobal?: true;
  organizationId?: true;
  action?: true;
  source?: true;
  lastUpdatedAt?: true;
};

export type WatchlistMaxAggregateInputType = {
  id?: true;
  type?: true;
  value?: true;
  description?: true;
  isGlobal?: true;
  organizationId?: true;
  action?: true;
  source?: true;
  lastUpdatedAt?: true;
};

export type WatchlistCountAggregateInputType = {
  id?: true;
  type?: true;
  value?: true;
  description?: true;
  isGlobal?: true;
  organizationId?: true;
  action?: true;
  source?: true;
  lastUpdatedAt?: true;
  _all?: true;
};

export type WatchlistAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Filter which Watchlist to aggregate.
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Watchlists to fetch.
   */
  orderBy?: Prisma.WatchlistOrderByWithRelationInput | Prisma.WatchlistOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.WatchlistWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Watchlists from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Watchlists.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Watchlists
   **/
  _count?: true | WatchlistCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: WatchlistAvgAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: WatchlistSumAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: WatchlistMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: WatchlistMaxAggregateInputType;
};

export type GetWatchlistAggregateType<T extends WatchlistAggregateArgs> = {
  [P in keyof T & keyof AggregateWatchlist]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateWatchlist[P]>
    : Prisma.GetScalarType<T[P], AggregateWatchlist[P]>;
};

export type WatchlistGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  where?: Prisma.WatchlistWhereInput;
  orderBy?: Prisma.WatchlistOrderByWithAggregationInput | Prisma.WatchlistOrderByWithAggregationInput[];
  by: Prisma.WatchlistScalarFieldEnum[] | Prisma.WatchlistScalarFieldEnum;
  having?: Prisma.WatchlistScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: WatchlistCountAggregateInputType | true;
  _avg?: WatchlistAvgAggregateInputType;
  _sum?: WatchlistSumAggregateInputType;
  _min?: WatchlistMinAggregateInputType;
  _max?: WatchlistMaxAggregateInputType;
};

export type WatchlistGroupByOutputType = {
  id: string;
  type: $Enums.WatchlistType;
  value: string;
  description: string | null;
  isGlobal: boolean;
  organizationId: number | null;
  action: $Enums.WatchlistAction;
  source: $Enums.WatchlistSource;
  lastUpdatedAt: Date;
  _count: WatchlistCountAggregateOutputType | null;
  _avg: WatchlistAvgAggregateOutputType | null;
  _sum: WatchlistSumAggregateOutputType | null;
  _min: WatchlistMinAggregateOutputType | null;
  _max: WatchlistMaxAggregateOutputType | null;
};

type GetWatchlistGroupByPayload<T extends WatchlistGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<WatchlistGroupByOutputType, T["by"]> & {
      [P in keyof T & keyof WatchlistGroupByOutputType]: P extends "_count"
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], WatchlistGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], WatchlistGroupByOutputType[P]>;
    }
  >
>;

export type WatchlistWhereInput = {
  AND?: Prisma.WatchlistWhereInput | Prisma.WatchlistWhereInput[];
  OR?: Prisma.WatchlistWhereInput[];
  NOT?: Prisma.WatchlistWhereInput | Prisma.WatchlistWhereInput[];
  id?: Prisma.UuidFilter<"Watchlist"> | string;
  type?: Prisma.EnumWatchlistTypeFilter<"Watchlist"> | $Enums.WatchlistType;
  value?: Prisma.StringFilter<"Watchlist"> | string;
  description?: Prisma.StringNullableFilter<"Watchlist"> | string | null;
  isGlobal?: Prisma.BoolFilter<"Watchlist"> | boolean;
  organizationId?: Prisma.IntNullableFilter<"Watchlist"> | number | null;
  action?: Prisma.EnumWatchlistActionFilter<"Watchlist"> | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFilter<"Watchlist"> | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFilter<"Watchlist"> | Date | string;
  bookingReports?: Prisma.BookingReportListRelationFilter;
  audits?: Prisma.WatchlistAuditListRelationFilter;
};

export type WatchlistOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  type?: Prisma.SortOrder;
  value?: Prisma.SortOrder;
  description?: Prisma.SortOrderInput | Prisma.SortOrder;
  isGlobal?: Prisma.SortOrder;
  organizationId?: Prisma.SortOrderInput | Prisma.SortOrder;
  action?: Prisma.SortOrder;
  source?: Prisma.SortOrder;
  lastUpdatedAt?: Prisma.SortOrder;
  bookingReports?: Prisma.BookingReportOrderByRelationAggregateInput;
  audits?: Prisma.WatchlistAuditOrderByRelationAggregateInput;
};

export type WatchlistWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    type_value_organizationId?: Prisma.WatchlistTypeValueOrganizationIdCompoundUniqueInput;
    AND?: Prisma.WatchlistWhereInput | Prisma.WatchlistWhereInput[];
    OR?: Prisma.WatchlistWhereInput[];
    NOT?: Prisma.WatchlistWhereInput | Prisma.WatchlistWhereInput[];
    type?: Prisma.EnumWatchlistTypeFilter<"Watchlist"> | $Enums.WatchlistType;
    value?: Prisma.StringFilter<"Watchlist"> | string;
    description?: Prisma.StringNullableFilter<"Watchlist"> | string | null;
    isGlobal?: Prisma.BoolFilter<"Watchlist"> | boolean;
    organizationId?: Prisma.IntNullableFilter<"Watchlist"> | number | null;
    action?: Prisma.EnumWatchlistActionFilter<"Watchlist"> | $Enums.WatchlistAction;
    source?: Prisma.EnumWatchlistSourceFilter<"Watchlist"> | $Enums.WatchlistSource;
    lastUpdatedAt?: Prisma.DateTimeFilter<"Watchlist"> | Date | string;
    bookingReports?: Prisma.BookingReportListRelationFilter;
    audits?: Prisma.WatchlistAuditListRelationFilter;
  },
  "id" | "type_value_organizationId"
>;

export type WatchlistOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  type?: Prisma.SortOrder;
  value?: Prisma.SortOrder;
  description?: Prisma.SortOrderInput | Prisma.SortOrder;
  isGlobal?: Prisma.SortOrder;
  organizationId?: Prisma.SortOrderInput | Prisma.SortOrder;
  action?: Prisma.SortOrder;
  source?: Prisma.SortOrder;
  lastUpdatedAt?: Prisma.SortOrder;
  _count?: Prisma.WatchlistCountOrderByAggregateInput;
  _avg?: Prisma.WatchlistAvgOrderByAggregateInput;
  _max?: Prisma.WatchlistMaxOrderByAggregateInput;
  _min?: Prisma.WatchlistMinOrderByAggregateInput;
  _sum?: Prisma.WatchlistSumOrderByAggregateInput;
};

export type WatchlistScalarWhereWithAggregatesInput = {
  AND?: Prisma.WatchlistScalarWhereWithAggregatesInput | Prisma.WatchlistScalarWhereWithAggregatesInput[];
  OR?: Prisma.WatchlistScalarWhereWithAggregatesInput[];
  NOT?: Prisma.WatchlistScalarWhereWithAggregatesInput | Prisma.WatchlistScalarWhereWithAggregatesInput[];
  id?: Prisma.UuidWithAggregatesFilter<"Watchlist"> | string;
  type?: Prisma.EnumWatchlistTypeWithAggregatesFilter<"Watchlist"> | $Enums.WatchlistType;
  value?: Prisma.StringWithAggregatesFilter<"Watchlist"> | string;
  description?: Prisma.StringNullableWithAggregatesFilter<"Watchlist"> | string | null;
  isGlobal?: Prisma.BoolWithAggregatesFilter<"Watchlist"> | boolean;
  organizationId?: Prisma.IntNullableWithAggregatesFilter<"Watchlist"> | number | null;
  action?: Prisma.EnumWatchlistActionWithAggregatesFilter<"Watchlist"> | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceWithAggregatesFilter<"Watchlist"> | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeWithAggregatesFilter<"Watchlist"> | Date | string;
};

export type WatchlistCreateInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  bookingReports?: Prisma.BookingReportCreateNestedManyWithoutWatchlistInput;
  audits?: Prisma.WatchlistAuditCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistUncheckedCreateInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  bookingReports?: Prisma.BookingReportUncheckedCreateNestedManyWithoutWatchlistInput;
  audits?: Prisma.WatchlistAuditUncheckedCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  bookingReports?: Prisma.BookingReportUpdateManyWithoutWatchlistNestedInput;
  audits?: Prisma.WatchlistAuditUpdateManyWithoutWatchlistNestedInput;
};

export type WatchlistUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  bookingReports?: Prisma.BookingReportUncheckedUpdateManyWithoutWatchlistNestedInput;
  audits?: Prisma.WatchlistAuditUncheckedUpdateManyWithoutWatchlistNestedInput;
};

export type WatchlistCreateManyInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
};

export type WatchlistUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type WatchlistUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type WatchlistTypeValueOrganizationIdCompoundUniqueInput = {
  type: $Enums.WatchlistType;
  value: string;
  organizationId: number;
};

export type WatchlistCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  type?: Prisma.SortOrder;
  value?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  isGlobal?: Prisma.SortOrder;
  organizationId?: Prisma.SortOrder;
  action?: Prisma.SortOrder;
  source?: Prisma.SortOrder;
  lastUpdatedAt?: Prisma.SortOrder;
};

export type WatchlistAvgOrderByAggregateInput = {
  organizationId?: Prisma.SortOrder;
};

export type WatchlistMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  type?: Prisma.SortOrder;
  value?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  isGlobal?: Prisma.SortOrder;
  organizationId?: Prisma.SortOrder;
  action?: Prisma.SortOrder;
  source?: Prisma.SortOrder;
  lastUpdatedAt?: Prisma.SortOrder;
};

export type WatchlistMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  type?: Prisma.SortOrder;
  value?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  isGlobal?: Prisma.SortOrder;
  organizationId?: Prisma.SortOrder;
  action?: Prisma.SortOrder;
  source?: Prisma.SortOrder;
  lastUpdatedAt?: Prisma.SortOrder;
};

export type WatchlistSumOrderByAggregateInput = {
  organizationId?: Prisma.SortOrder;
};

export type WatchlistNullableScalarRelationFilter = {
  is?: Prisma.WatchlistWhereInput | null;
  isNot?: Prisma.WatchlistWhereInput | null;
};

export type EnumWatchlistTypeFieldUpdateOperationsInput = {
  set?: $Enums.WatchlistType;
};

export type EnumWatchlistActionFieldUpdateOperationsInput = {
  set?: $Enums.WatchlistAction;
};

export type EnumWatchlistSourceFieldUpdateOperationsInput = {
  set?: $Enums.WatchlistSource;
};

export type WatchlistCreateNestedOneWithoutAuditsInput = {
  create?: Prisma.XOR<
    Prisma.WatchlistCreateWithoutAuditsInput,
    Prisma.WatchlistUncheckedCreateWithoutAuditsInput
  >;
  connectOrCreate?: Prisma.WatchlistCreateOrConnectWithoutAuditsInput;
  connect?: Prisma.WatchlistWhereUniqueInput;
};

export type WatchlistUpdateOneWithoutAuditsNestedInput = {
  create?: Prisma.XOR<
    Prisma.WatchlistCreateWithoutAuditsInput,
    Prisma.WatchlistUncheckedCreateWithoutAuditsInput
  >;
  connectOrCreate?: Prisma.WatchlistCreateOrConnectWithoutAuditsInput;
  upsert?: Prisma.WatchlistUpsertWithoutAuditsInput;
  disconnect?: Prisma.WatchlistWhereInput | boolean;
  delete?: Prisma.WatchlistWhereInput | boolean;
  connect?: Prisma.WatchlistWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WatchlistUpdateToOneWithWhereWithoutAuditsInput,
      Prisma.WatchlistUpdateWithoutAuditsInput
    >,
    Prisma.WatchlistUncheckedUpdateWithoutAuditsInput
  >;
};

export type WatchlistCreateNestedOneWithoutBookingReportsInput = {
  create?: Prisma.XOR<
    Prisma.WatchlistCreateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedCreateWithoutBookingReportsInput
  >;
  connectOrCreate?: Prisma.WatchlistCreateOrConnectWithoutBookingReportsInput;
  connect?: Prisma.WatchlistWhereUniqueInput;
};

export type WatchlistUpdateOneWithoutBookingReportsNestedInput = {
  create?: Prisma.XOR<
    Prisma.WatchlistCreateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedCreateWithoutBookingReportsInput
  >;
  connectOrCreate?: Prisma.WatchlistCreateOrConnectWithoutBookingReportsInput;
  upsert?: Prisma.WatchlistUpsertWithoutBookingReportsInput;
  disconnect?: Prisma.WatchlistWhereInput | boolean;
  delete?: Prisma.WatchlistWhereInput | boolean;
  connect?: Prisma.WatchlistWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.WatchlistUpdateToOneWithWhereWithoutBookingReportsInput,
      Prisma.WatchlistUpdateWithoutBookingReportsInput
    >,
    Prisma.WatchlistUncheckedUpdateWithoutBookingReportsInput
  >;
};

export type WatchlistCreateWithoutAuditsInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  bookingReports?: Prisma.BookingReportCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistUncheckedCreateWithoutAuditsInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  bookingReports?: Prisma.BookingReportUncheckedCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistCreateOrConnectWithoutAuditsInput = {
  where: Prisma.WatchlistWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WatchlistCreateWithoutAuditsInput,
    Prisma.WatchlistUncheckedCreateWithoutAuditsInput
  >;
};

export type WatchlistUpsertWithoutAuditsInput = {
  update: Prisma.XOR<
    Prisma.WatchlistUpdateWithoutAuditsInput,
    Prisma.WatchlistUncheckedUpdateWithoutAuditsInput
  >;
  create: Prisma.XOR<
    Prisma.WatchlistCreateWithoutAuditsInput,
    Prisma.WatchlistUncheckedCreateWithoutAuditsInput
  >;
  where?: Prisma.WatchlistWhereInput;
};

export type WatchlistUpdateToOneWithWhereWithoutAuditsInput = {
  where?: Prisma.WatchlistWhereInput;
  data: Prisma.XOR<
    Prisma.WatchlistUpdateWithoutAuditsInput,
    Prisma.WatchlistUncheckedUpdateWithoutAuditsInput
  >;
};

export type WatchlistUpdateWithoutAuditsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  bookingReports?: Prisma.BookingReportUpdateManyWithoutWatchlistNestedInput;
};

export type WatchlistUncheckedUpdateWithoutAuditsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  bookingReports?: Prisma.BookingReportUncheckedUpdateManyWithoutWatchlistNestedInput;
};

export type WatchlistCreateWithoutBookingReportsInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  audits?: Prisma.WatchlistAuditCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistUncheckedCreateWithoutBookingReportsInput = {
  id?: string;
  type: $Enums.WatchlistType;
  value: string;
  description?: string | null;
  isGlobal?: boolean;
  organizationId?: number | null;
  action?: $Enums.WatchlistAction;
  source?: $Enums.WatchlistSource;
  lastUpdatedAt?: Date | string;
  audits?: Prisma.WatchlistAuditUncheckedCreateNestedManyWithoutWatchlistInput;
};

export type WatchlistCreateOrConnectWithoutBookingReportsInput = {
  where: Prisma.WatchlistWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.WatchlistCreateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedCreateWithoutBookingReportsInput
  >;
};

export type WatchlistUpsertWithoutBookingReportsInput = {
  update: Prisma.XOR<
    Prisma.WatchlistUpdateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedUpdateWithoutBookingReportsInput
  >;
  create: Prisma.XOR<
    Prisma.WatchlistCreateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedCreateWithoutBookingReportsInput
  >;
  where?: Prisma.WatchlistWhereInput;
};

export type WatchlistUpdateToOneWithWhereWithoutBookingReportsInput = {
  where?: Prisma.WatchlistWhereInput;
  data: Prisma.XOR<
    Prisma.WatchlistUpdateWithoutBookingReportsInput,
    Prisma.WatchlistUncheckedUpdateWithoutBookingReportsInput
  >;
};

export type WatchlistUpdateWithoutBookingReportsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  audits?: Prisma.WatchlistAuditUpdateManyWithoutWatchlistNestedInput;
};

export type WatchlistUncheckedUpdateWithoutBookingReportsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  type?: Prisma.EnumWatchlistTypeFieldUpdateOperationsInput | $Enums.WatchlistType;
  value?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  isGlobal?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  organizationId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
  action?: Prisma.EnumWatchlistActionFieldUpdateOperationsInput | $Enums.WatchlistAction;
  source?: Prisma.EnumWatchlistSourceFieldUpdateOperationsInput | $Enums.WatchlistSource;
  lastUpdatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  audits?: Prisma.WatchlistAuditUncheckedUpdateManyWithoutWatchlistNestedInput;
};

/**
 * Count Type WatchlistCountOutputType
 */

export type WatchlistCountOutputType = {
  bookingReports: number;
  audits: number;
};

export type WatchlistCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  bookingReports?: boolean | WatchlistCountOutputTypeCountBookingReportsArgs;
  audits?: boolean | WatchlistCountOutputTypeCountAuditsArgs;
};

/**
 * WatchlistCountOutputType without action
 */
export type WatchlistCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the WatchlistCountOutputType
   */
  select?: Prisma.WatchlistCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * WatchlistCountOutputType without action
 */
export type WatchlistCountOutputTypeCountBookingReportsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  where?: Prisma.BookingReportWhereInput;
};

/**
 * WatchlistCountOutputType without action
 */
export type WatchlistCountOutputTypeCountAuditsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  where?: Prisma.WatchlistAuditWhereInput;
};

export type WatchlistSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    type?: boolean;
    value?: boolean;
    description?: boolean;
    isGlobal?: boolean;
    organizationId?: boolean;
    action?: boolean;
    source?: boolean;
    lastUpdatedAt?: boolean;
    bookingReports?: boolean | Prisma.Watchlist$bookingReportsArgs<ExtArgs>;
    audits?: boolean | Prisma.Watchlist$auditsArgs<ExtArgs>;
    _count?: boolean | Prisma.WatchlistCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["watchlist"]
>;

export type WatchlistSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    type?: boolean;
    value?: boolean;
    description?: boolean;
    isGlobal?: boolean;
    organizationId?: boolean;
    action?: boolean;
    source?: boolean;
    lastUpdatedAt?: boolean;
  },
  ExtArgs["result"]["watchlist"]
>;

export type WatchlistSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    type?: boolean;
    value?: boolean;
    description?: boolean;
    isGlobal?: boolean;
    organizationId?: boolean;
    action?: boolean;
    source?: boolean;
    lastUpdatedAt?: boolean;
  },
  ExtArgs["result"]["watchlist"]
>;

export type WatchlistSelectScalar = {
  id?: boolean;
  type?: boolean;
  value?: boolean;
  description?: boolean;
  isGlobal?: boolean;
  organizationId?: boolean;
  action?: boolean;
  source?: boolean;
  lastUpdatedAt?: boolean;
};

export type WatchlistOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "type"
  | "value"
  | "description"
  | "isGlobal"
  | "organizationId"
  | "action"
  | "source"
  | "lastUpdatedAt",
  ExtArgs["result"]["watchlist"]
>;
export type WatchlistInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  bookingReports?: boolean | Prisma.Watchlist$bookingReportsArgs<ExtArgs>;
  audits?: boolean | Prisma.Watchlist$auditsArgs<ExtArgs>;
  _count?: boolean | Prisma.WatchlistCountOutputTypeDefaultArgs<ExtArgs>;
};
export type WatchlistIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {};
export type WatchlistIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {};

export type $WatchlistPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  name: "Watchlist";
  objects: {
    bookingReports: Prisma.$BookingReportPayload<ExtArgs>[];
    audits: Prisma.$WatchlistAuditPayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      type: $Enums.WatchlistType;
      value: string;
      description: string | null;
      isGlobal: boolean;
      organizationId: number | null;
      action: $Enums.WatchlistAction;
      source: $Enums.WatchlistSource;
      lastUpdatedAt: Date;
    },
    ExtArgs["result"]["watchlist"]
  >;
  composites: {};
};

export type WatchlistGetPayload<S extends boolean | null | undefined | WatchlistDefaultArgs> =
  runtime.Types.Result.GetResult<Prisma.$WatchlistPayload, S>;

export type WatchlistCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = Omit<WatchlistFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: WatchlistCountAggregateInputType | true;
};

export interface WatchlistDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {}
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Watchlist"]; meta: { name: "Watchlist" } };
  /**
   * Find zero or one Watchlist that matches the filter.
   * @param {WatchlistFindUniqueArgs} args - Arguments to find a Watchlist
   * @example
   * // Get one Watchlist
   * const watchlist = await prisma.watchlist.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends WatchlistFindUniqueArgs>(
    args: Prisma.SelectSubset<T, WatchlistFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Watchlist that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {WatchlistFindUniqueOrThrowArgs} args - Arguments to find a Watchlist
   * @example
   * // Get one Watchlist
   * const watchlist = await prisma.watchlist.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends WatchlistFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, WatchlistFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Watchlist that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistFindFirstArgs} args - Arguments to find a Watchlist
   * @example
   * // Get one Watchlist
   * const watchlist = await prisma.watchlist.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends WatchlistFindFirstArgs>(
    args?: Prisma.SelectSubset<T, WatchlistFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Watchlist that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistFindFirstOrThrowArgs} args - Arguments to find a Watchlist
   * @example
   * // Get one Watchlist
   * const watchlist = await prisma.watchlist.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends WatchlistFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, WatchlistFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Watchlists that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Watchlists
   * const watchlists = await prisma.watchlist.findMany()
   *
   * // Get first 10 Watchlists
   * const watchlists = await prisma.watchlist.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const watchlistWithIdOnly = await prisma.watchlist.findMany({ select: { id: true } })
   *
   */
  findMany<T extends WatchlistFindManyArgs>(
    args?: Prisma.SelectSubset<T, WatchlistFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
  >;

  /**
   * Create a Watchlist.
   * @param {WatchlistCreateArgs} args - Arguments to create a Watchlist.
   * @example
   * // Create one Watchlist
   * const Watchlist = await prisma.watchlist.create({
   *   data: {
   *     // ... data to create a Watchlist
   *   }
   * })
   *
   */
  create<T extends WatchlistCreateArgs>(
    args: Prisma.SelectSubset<T, WatchlistCreateArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Watchlists.
   * @param {WatchlistCreateManyArgs} args - Arguments to create many Watchlists.
   * @example
   * // Create many Watchlists
   * const watchlist = await prisma.watchlist.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends WatchlistCreateManyArgs>(
    args?: Prisma.SelectSubset<T, WatchlistCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Watchlists and returns the data saved in the database.
   * @param {WatchlistCreateManyAndReturnArgs} args - Arguments to create many Watchlists.
   * @example
   * // Create many Watchlists
   * const watchlist = await prisma.watchlist.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Watchlists and only return the `id`
   * const watchlistWithIdOnly = await prisma.watchlist.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends WatchlistCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, WatchlistCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Watchlist.
   * @param {WatchlistDeleteArgs} args - Arguments to delete one Watchlist.
   * @example
   * // Delete one Watchlist
   * const Watchlist = await prisma.watchlist.delete({
   *   where: {
   *     // ... filter to delete one Watchlist
   *   }
   * })
   *
   */
  delete<T extends WatchlistDeleteArgs>(
    args: Prisma.SelectSubset<T, WatchlistDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Watchlist.
   * @param {WatchlistUpdateArgs} args - Arguments to update one Watchlist.
   * @example
   * // Update one Watchlist
   * const watchlist = await prisma.watchlist.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends WatchlistUpdateArgs>(
    args: Prisma.SelectSubset<T, WatchlistUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Watchlists.
   * @param {WatchlistDeleteManyArgs} args - Arguments to filter Watchlists to delete.
   * @example
   * // Delete a few Watchlists
   * const { count } = await prisma.watchlist.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends WatchlistDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, WatchlistDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Watchlists.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Watchlists
   * const watchlist = await prisma.watchlist.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends WatchlistUpdateManyArgs>(
    args: Prisma.SelectSubset<T, WatchlistUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Watchlists and returns the data updated in the database.
   * @param {WatchlistUpdateManyAndReturnArgs} args - Arguments to update many Watchlists.
   * @example
   * // Update many Watchlists
   * const watchlist = await prisma.watchlist.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Watchlists and only return the `id`
   * const watchlistWithIdOnly = await prisma.watchlist.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends WatchlistUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, WatchlistUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$WatchlistPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Watchlist.
   * @param {WatchlistUpsertArgs} args - Arguments to update or create a Watchlist.
   * @example
   * // Update or create a Watchlist
   * const watchlist = await prisma.watchlist.upsert({
   *   create: {
   *     // ... data to create a Watchlist
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Watchlist we want to update
   *   }
   * })
   */
  upsert<T extends WatchlistUpsertArgs>(
    args: Prisma.SelectSubset<T, WatchlistUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__WatchlistClient<
    runtime.Types.Result.GetResult<Prisma.$WatchlistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Watchlists.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistCountArgs} args - Arguments to filter Watchlists to count.
   * @example
   * // Count the number of Watchlists
   * const count = await prisma.watchlist.count({
   *   where: {
   *     // ... the filter for the Watchlists we want to count
   *   }
   * })
   **/
  count<T extends WatchlistCountArgs>(
    args?: Prisma.Subset<T, WatchlistCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], WatchlistCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Watchlist.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends WatchlistAggregateArgs>(
    args: Prisma.Subset<T, WatchlistAggregateArgs>
  ): Prisma.PrismaPromise<GetWatchlistAggregateType<T>>;

  /**
   * Group by Watchlist.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WatchlistGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends WatchlistGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: WatchlistGroupByArgs["orderBy"] }
      : { orderBy?: WatchlistGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
        }[HavingFields]
      : "take" extends Prisma.Keys<T>
      ? "orderBy" extends Prisma.Keys<T>
        ? ByValid extends Prisma.True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : "skip" extends Prisma.Keys<T>
      ? "orderBy" extends Prisma.Keys<T>
        ? ByValid extends Prisma.True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends Prisma.True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
        }[OrderFields]
  >(
    args: Prisma.SubsetIntersection<T, WatchlistGroupByArgs, OrderByArg> & InputErrors
  ): {} extends InputErrors ? GetWatchlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Watchlist model
   */
  readonly fields: WatchlistFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Watchlist.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__WatchlistClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {}
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  bookingReports<T extends Prisma.Watchlist$bookingReportsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Watchlist$bookingReportsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<Prisma.$BookingReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    | Null
  >;
  audits<T extends Prisma.Watchlist$auditsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Watchlist$auditsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<Prisma.$WatchlistAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Watchlist model
 */
export interface WatchlistFieldRefs {
  readonly id: Prisma.FieldRef<"Watchlist", "String">;
  readonly type: Prisma.FieldRef<"Watchlist", "WatchlistType">;
  readonly value: Prisma.FieldRef<"Watchlist", "String">;
  readonly description: Prisma.FieldRef<"Watchlist", "String">;
  readonly isGlobal: Prisma.FieldRef<"Watchlist", "Boolean">;
  readonly organizationId: Prisma.FieldRef<"Watchlist", "Int">;
  readonly action: Prisma.FieldRef<"Watchlist", "WatchlistAction">;
  readonly source: Prisma.FieldRef<"Watchlist", "WatchlistSource">;
  readonly lastUpdatedAt: Prisma.FieldRef<"Watchlist", "DateTime">;
}

// Custom InputTypes
/**
 * Watchlist findUnique
 */
export type WatchlistFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter, which Watchlist to fetch.
   */
  where: Prisma.WatchlistWhereUniqueInput;
};

/**
 * Watchlist findUniqueOrThrow
 */
export type WatchlistFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter, which Watchlist to fetch.
   */
  where: Prisma.WatchlistWhereUniqueInput;
};

/**
 * Watchlist findFirst
 */
export type WatchlistFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter, which Watchlist to fetch.
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Watchlists to fetch.
   */
  orderBy?: Prisma.WatchlistOrderByWithRelationInput | Prisma.WatchlistOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Watchlists.
   */
  cursor?: Prisma.WatchlistWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Watchlists from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Watchlists.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Watchlists.
   */
  distinct?: Prisma.WatchlistScalarFieldEnum | Prisma.WatchlistScalarFieldEnum[];
};

/**
 * Watchlist findFirstOrThrow
 */
export type WatchlistFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter, which Watchlist to fetch.
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Watchlists to fetch.
   */
  orderBy?: Prisma.WatchlistOrderByWithRelationInput | Prisma.WatchlistOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Watchlists.
   */
  cursor?: Prisma.WatchlistWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Watchlists from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Watchlists.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Watchlists.
   */
  distinct?: Prisma.WatchlistScalarFieldEnum | Prisma.WatchlistScalarFieldEnum[];
};

/**
 * Watchlist findMany
 */
export type WatchlistFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter, which Watchlists to fetch.
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Watchlists to fetch.
   */
  orderBy?: Prisma.WatchlistOrderByWithRelationInput | Prisma.WatchlistOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Watchlists.
   */
  cursor?: Prisma.WatchlistWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Watchlists from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Watchlists.
   */
  skip?: number;
  distinct?: Prisma.WatchlistScalarFieldEnum | Prisma.WatchlistScalarFieldEnum[];
};

/**
 * Watchlist create
 */
export type WatchlistCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * The data needed to create a Watchlist.
   */
  data: Prisma.XOR<Prisma.WatchlistCreateInput, Prisma.WatchlistUncheckedCreateInput>;
};

/**
 * Watchlist createMany
 */
export type WatchlistCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * The data used to create many Watchlists.
   */
  data: Prisma.WatchlistCreateManyInput | Prisma.WatchlistCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Watchlist createManyAndReturn
 */
export type WatchlistCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * The data used to create many Watchlists.
   */
  data: Prisma.WatchlistCreateManyInput | Prisma.WatchlistCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Watchlist update
 */
export type WatchlistUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * The data needed to update a Watchlist.
   */
  data: Prisma.XOR<Prisma.WatchlistUpdateInput, Prisma.WatchlistUncheckedUpdateInput>;
  /**
   * Choose, which Watchlist to update.
   */
  where: Prisma.WatchlistWhereUniqueInput;
};

/**
 * Watchlist updateMany
 */
export type WatchlistUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * The data used to update Watchlists.
   */
  data: Prisma.XOR<Prisma.WatchlistUpdateManyMutationInput, Prisma.WatchlistUncheckedUpdateManyInput>;
  /**
   * Filter which Watchlists to update
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * Limit how many Watchlists to update.
   */
  limit?: number;
};

/**
 * Watchlist updateManyAndReturn
 */
export type WatchlistUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * The data used to update Watchlists.
   */
  data: Prisma.XOR<Prisma.WatchlistUpdateManyMutationInput, Prisma.WatchlistUncheckedUpdateManyInput>;
  /**
   * Filter which Watchlists to update
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * Limit how many Watchlists to update.
   */
  limit?: number;
};

/**
 * Watchlist upsert
 */
export type WatchlistUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * The filter to search for the Watchlist to update in case it exists.
   */
  where: Prisma.WatchlistWhereUniqueInput;
  /**
   * In case the Watchlist found by the `where` argument doesn't exist, create a new Watchlist with this data.
   */
  create: Prisma.XOR<Prisma.WatchlistCreateInput, Prisma.WatchlistUncheckedCreateInput>;
  /**
   * In case the Watchlist was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.WatchlistUpdateInput, Prisma.WatchlistUncheckedUpdateInput>;
};

/**
 * Watchlist delete
 */
export type WatchlistDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
  /**
   * Filter which Watchlist to delete.
   */
  where: Prisma.WatchlistWhereUniqueInput;
};

/**
 * Watchlist deleteMany
 */
export type WatchlistDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Filter which Watchlists to delete
   */
  where?: Prisma.WatchlistWhereInput;
  /**
   * Limit how many Watchlists to delete.
   */
  limit?: number;
};

/**
 * Watchlist.bookingReports
 */
export type Watchlist$bookingReportsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the BookingReport
   */
  select?: Prisma.BookingReportSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the BookingReport
   */
  omit?: Prisma.BookingReportOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookingReportInclude<ExtArgs> | null;
  where?: Prisma.BookingReportWhereInput;
  orderBy?: Prisma.BookingReportOrderByWithRelationInput | Prisma.BookingReportOrderByWithRelationInput[];
  cursor?: Prisma.BookingReportWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.BookingReportScalarFieldEnum | Prisma.BookingReportScalarFieldEnum[];
};

/**
 * Watchlist.audits
 */
export type Watchlist$auditsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the WatchlistAudit
   */
  select?: Prisma.WatchlistAuditSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the WatchlistAudit
   */
  omit?: Prisma.WatchlistAuditOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistAuditInclude<ExtArgs> | null;
  where?: Prisma.WatchlistAuditWhereInput;
  orderBy?: Prisma.WatchlistAuditOrderByWithRelationInput | Prisma.WatchlistAuditOrderByWithRelationInput[];
  cursor?: Prisma.WatchlistAuditWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.WatchlistAuditScalarFieldEnum | Prisma.WatchlistAuditScalarFieldEnum[];
};

/**
 * Watchlist without action
 */
export type WatchlistDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
  /**
   * Select specific fields to fetch from the Watchlist
   */
  select?: Prisma.WatchlistSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Watchlist
   */
  omit?: Prisma.WatchlistOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WatchlistInclude<ExtArgs> | null;
};
