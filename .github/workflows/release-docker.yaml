name: "Release Docker"

env:
  POSTGRES_USER: "unicorn_user"
  POSTGRES_PASSWORD: "magical_password"
  POSTGRES_DB: "calendso"
  DATABASE_HOST: "database:5432"

on:
  push:
    tags:
      - "v*"
  # in case manual trigger is needed
  workflow_dispatch:
    inputs:
      RELEASE_TAG:
        description: "v{Major}.{Minor}.{Patch}"

jobs:
  release:
    name: "Release"
    runs-on: buildjet-4vcpu-ubuntu-2204
    steps:
      - name: checkout
        uses: actions/checkout@v4
        # with:
        #   # Check out the tag specified in workflow_dispatch, or the tag that triggered the push event
        #   ref: ${{ github.event.inputs.RELEASE_TAG || github.ref }}

      - name: "Determine tag"
        # The logic here assumes `github.ref` is present, which is true for 'push: tags' or when `ref` is set in 'checkout'
        run: 'echo "RELEASE_TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV'

      - name: Log in to the Docker Hub registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          logout: true

      - name: Log in to the Github Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            docker.io/calendso/calendso
            docker.io/calcom/cal.com
            ghcr.io/calcom/cal.com
          # Add flavor latest only on full releases, not on pre-releases
          flavor: |
            latest=${{ !github.event.release.prerelease }}

      - name: Copy env
        run: |
          grep -o '^[^#]*' .env.example > .env
          cat .env >> $GITHUB_ENV
          echo "DATABASE_HOST=localhost:5432" >> $GITHUB_ENV
          eval $(sed -e '/^#/d' -e 's/^/export /' -e 's/$/;/' .env) ;

      - name: Start database
        run: |
          docker compose up -d database

      - name: Show database logs and container status
        run: |
          echo "--- Container Status ---"
          docker compose ps database

          echo "--- Container Logs ---"
          docker compose logs database

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=container:database
          buildkitd-flags: |
            --allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host

      - name: Build image
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: ./
          file: ./Dockerfile
          load: true # Load the image into the Docker daemon
          push: false # Do not push the image at this stage
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_WEBAPP_URL=http://localhost:3000
            NEXT_PUBLIC_API_V2_URL=http://localhost:5555/api/v2
            NEXT_PUBLIC_LICENSE_CONSENT=agree
            DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@${{ env.DATABASE_HOST }}/${{ env.POSTGRES_DB }}
            DATABASE_DIRECT_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@${{ env.DATABASE_HOST }}/${{ env.POSTGRES_DB }}

      - name: Test runtime
        run: |
          tags="${{ steps.meta.outputs.tags }}"
          IFS=',' read -ra ADDR <<< "$tags"  # Convert string to array using ',' as delimiter
          tag=${ADDR[0]}  # Get the first tag

          docker run --rm --network stack \
            -p 3000:3000 \
            -e DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@database/${{ env.POSTGRES_DB }} \
            -e DATABASE_DIRECT_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@database/${{ env.POSTGRES_DB }} \
            -e NEXTAUTH_SECRET=${{ env.NEXTAUTH_SECRET }} \
            -e CALENDSO_ENCRYPTION_KEY=${{ env.CALENDSO_ENCRYPTION_KEY }} \
            $tag &

            server_pid=$!


            echo "Waiting for the server to start..."
            sleep 120

            echo ${{ env.NEXT_PUBLIC_WEBAPP_URL }}/auth/login

            for i in {1..60}; do
              echo "Checking server health ($i/60)..."
              response=$(curl -o /dev/null -s -w "%{http_code}" ${{ env.NEXT_PUBLIC_WEBAPP_URL }}/auth/login)
              echo "HTTP Status Code: $response"
              if [[ "$response" == "200" ]] || [[ "$response" == "307" ]]; then
                echo "Server is healthy"
                # Now, shutdown the server
                kill $server_pid
                exit 0
              fi
              sleep 1
            done

            echo "Server health check failed"
            kill $server_pid
            exit 1
        env:
          NEXTAUTH_SECRET: "EI4qqDpcfdvf4A+0aQEEx8JjHxHSy4uWiZw/F32K+pA="
          CALENDSO_ENCRYPTION_KEY: "0zfLtY99wjeLnsM7qsa8xsT+Q0oSgnOL"

      # - name: Push image
      #   id: docker_push
      #   uses: docker/build-push-action@v6
      #   with:
      #     context: ./
      #     file: ./Dockerfile
      #     push: true
      #     platforms: linux/amd64
      #     tags: ${{ steps.meta.outputs.tags }}
      #     labels: ${{ steps.meta.outputs.labels }}
      #     build-args: |
      #       NEXT_PUBLIC_WEBAPP_URL=${{ env.NEXT_PUBLIC_WEBAPP_URL }}
      #       NEXT_PUBLIC_API_V2_URL=${{ env.NEXT_PUBLIC_API_V2_URL }}
      #       NEXT_PUBLIC_LICENSE_CONSENT=${{ env.NEXT_PUBLIC_LICENSE_CONSENT }}
      #       NEXT_PUBLIC_TELEMETRY_KEY=${{ env.NEXT_PUBLIC_TELEMETRY_KEY }}
      #       DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@${{ env.DATABASE_HOST }}/${{ env.POSTGRES_DB }}
      #       DATABASE_DIRECT_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@${{ env.DATABASE_HOST }}/${{ env.POSTGRES_DB }}
      #   if: ${{ !github.event.release.prerelease }}

      - name: Image digest
        run: echo ${{ steps.docker_build.outputs.digest }}

      - name: Cleanup
        run: |
          docker compose down

      - name: Notify Slack on Success
        if: success()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":large_green_circle: Workflow *${{ github.workflow }}* succeeded in job *${{ github.job }}*.\nSee: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.CI_SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Failure
        if: failure()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":red_circle: Workflow *${{ github.workflow }}* failed in job *${{ github.job }}*.\nSee: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.CI_SLACK_WEBHOOK_URL }}
