name: Run CI

on:
  pull_request_target:
    types: [labeled]

permissions:
  actions: write
  contents: read

jobs:
  trigger:
    name: Trigger CI
    if: github.event.label.name == 'run-ci' || github.event.label.name == 'ready-for-e2e'
    runs-on: ubuntu-latest
    steps:
      - name: Verify and trigger CI
        uses: actions/github-script@v7
        with:
          script: |
            const adder = context.payload.sender.login;
            const senderType = context.payload.sender.type;
            const pr = context.payload.pull_request;
            const installation = context.payload.installation;

            // Trusted GitHub App IDs that can add labels to trigger CI
            // Graphite App: https://github.com/apps/graphite-app
            const GRAPHITE_APP_ID = 15497;
            const trustedAppIds = [GRAPHITE_APP_ID];

            let isAuthorized = false;

            // Check if this is a GitHub App (Bot) with an installation context
            if (senderType === 'Bot' && installation?.id) {
              try {
                // Get the installation details to verify the app_id
                const { data: installationData } = await github.rest.apps.getInstallation({
                  installation_id: installation.id,
                });

                if (trustedAppIds.includes(installationData.app_id)) {
                  console.log(`Label added by trusted GitHub App: ${adder} (app_id: ${installationData.app_id})`);
                  isAuthorized = true;
                } else {
                  console.log(`GitHub App ${adder} (app_id: ${installationData.app_id}) is not in the trusted list`);
                }
              } catch (error) {
                console.log(`Could not verify GitHub App installation: ${error.message}`);
                // Fall through to human permission check
              }
            }

            // If not authorized by app check, verify human has write access
            if (!isAuthorized) {
              const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: adder,
              });

              if (!['admin', 'maintain', 'write'].includes(perm.permission)) {
                core.setFailed(`${adder} does not have write access`);
                return;
              }

              console.log(`Label added by ${adder} (${perm.permission})`);
            }

            // Find the latest pr.yml run for this PR's head SHA
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'pr.yml',
              head_sha: pr.head.sha,
              per_page: 5,
            });

            // Filter runs to this PR (in case same SHA exists in multiple PRs)
            const matchingRuns = runs.workflow_runs.filter(run =>
              !run.pull_requests?.length || run.pull_requests.some(p => p.number === pr.number)
            );

            if (matchingRuns.length === 0) {
              core.setFailed(`No PR workflow found for SHA ${pr.head.sha}`);
              return;
            }

            const latestRun = matchingRuns[0];

            // If workflow is still running, cancel it first then re-run
            if (latestRun.status === 'in_progress' || latestRun.status === 'queued') {
              console.log(`Workflow is running (status: ${latestRun.status}). Cancelling it first...`);

              await github.rest.actions.cancelWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id,
              });

              // Wait for the workflow to be cancelled (poll with timeout)
              const maxWaitTime = 60000; // 60 seconds
              const pollInterval = 2000; // 2 seconds
              const startTime = Date.now();

              while (Date.now() - startTime < maxWaitTime) {
                await new Promise(resolve => setTimeout(resolve, pollInterval));

                const { data: updatedRun } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: latestRun.id,
                });

                if (updatedRun.status === 'completed') {
                  console.log(`Workflow cancelled successfully (conclusion: ${updatedRun.conclusion})`);
                  break;
                }

                console.log(`Waiting for workflow to cancel... (status: ${updatedRun.status})`);
              }

              // Check final status
              const { data: finalRun } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id,
              });

              if (finalRun.status !== 'completed') {
                core.setFailed(`Timed out waiting for workflow to cancel (status: ${finalRun.status})`);
                return;
              }
            }

            console.log(`Re-running workflow ${latestRun.id} (was: ${latestRun.conclusion || latestRun.status})`);

            // Re-run preserves original context (PR, SHA, etc.)
            await github.rest.actions.reRunWorkflow({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: latestRun.id,
            });

            console.log(`Triggered: ${latestRun.html_url}`);
