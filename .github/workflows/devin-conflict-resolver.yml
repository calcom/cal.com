name: Devin PR Conflict Resolver

on:
  # Run every 5 minutes instead of on push to main.
  # This saves runner costs by avoiding the 20-second sleep that was needed
  # to wait for GitHub to compute mergeable status after merges to main.
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to resolve conflicts for (optional, bypasses maintainer access check for fork PRs)'
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write

jobs:
  check-conflicts:
    name: Check Open PRs for Conflicts
    runs-on: blacksmith-2vcpu-ubuntu-2404
    steps:
      - name: Get open PRs and check for conflicts
        id: check-prs
        uses: actions/github-script@v7
        env:
          INPUT_PR_NUMBER: ${{ inputs.pr_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const manualPrNumber = process.env.INPUT_PR_NUMBER ? parseInt(process.env.INPUT_PR_NUMBER, 10) : null;
            
            const query = `
              query($owner: String!, $repo: String!, $cursor: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(states: OPEN, first: 100, after: $cursor) {
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      number
                      title
                      mergeable
                      isDraft
                      headRefName
                      baseRefName
                      url
                      headRepository {
                        owner {
                          login
                        }
                        name
                      }
                      maintainerCanModify
                      labels(first: 10) {
                        nodes {
                          name
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const allPRs = [];
            let cursor = null;
            
            do {
              const result = await github.graphql(query, { owner, repo, cursor });
              const { nodes, pageInfo } = result.repository.pullRequests;
              allPRs.push(...nodes);
              cursor = pageInfo.hasNextPage ? pageInfo.endCursor : null;
            } while (cursor);
            
            console.log(`Found ${allPRs.length} open PRs via GraphQL`);
            
            if (manualPrNumber) {
              console.log(`Manual PR number provided: ${manualPrNumber}`);
            }
            
            const conflictingPRs = [];
            const unknownPRs = [];
            
            function processPR(pr, mergeableStatus) {
              const isTargetPR = manualPrNumber && pr.number === manualPrNumber;
              const isFork = pr.headRepository?.owner?.login !== owner;
              
              if (!isTargetPR && pr.isDraft) {
                console.log(`PR #${pr.number} is a draft, skipping`);
                return { skip: true };
              }
              
              if (!isTargetPR && isFork) {
                console.log(`PR #${pr.number} is from a fork, skipping`);
                return { skip: true };
              }
              
              if (!isTargetPR) {
                const hasDevinLabel = pr.labels.nodes.some(label => label.name === 'devin-conflict-resolution');
                if (hasDevinLabel) {
                  console.log(`PR #${pr.number} already has devin-conflict-resolution label, skipping`);
                  return { skip: true };
                }
              }
              
              if (mergeableStatus === 'CONFLICTING' || (isTargetPR && mergeableStatus !== 'MERGEABLE')) {
                const headRepoOwner = pr.headRepository?.owner?.login || owner;
                const headRepoName = pr.headRepository?.name || repo;
                
                if (isTargetPR) {
                  console.log(`PR #${pr.number} manually targeted for conflict resolution${isFork ? ' (from fork)' : ''}`);
                } else {
                  console.log(`PR #${pr.number} has conflicts`);
                }
                
                return {
                  conflict: true,
                  data: {
                    number: pr.number,
                    title: pr.title,
                    head_ref: pr.headRefName,
                    base_ref: pr.baseRefName,
                    html_url: pr.url,
                    is_fork: isFork,
                    head_repo_owner: headRepoOwner,
                    head_repo_name: headRepoName,
                    is_manual: isTargetPR
                  },
                  isTargetPR
                };
              } else if (mergeableStatus === 'UNKNOWN') {
                return { unknown: true, isTargetPR };
              } else {
                console.log(`PR #${pr.number} has no conflicts (mergeable: ${mergeableStatus})`);
                return { skip: true };
              }
            }
            
            for (const pr of allPRs) {
              const result = processPR(pr, pr.mergeable);
              
              if (result.conflict) {
                conflictingPRs.push(result.data);
                if (result.isTargetPR) break;
              } else if (result.unknown) {
                console.log(`PR #${pr.number} mergeable status is still being computed`);
                unknownPRs.push(pr);
              }
            }
            
            if (unknownPRs.length > 0) {
              console.log(`\n${unknownPRs.length} PRs have UNKNOWN mergeable status, retrying via REST API...`);
              
              for (const pr of unknownPRs) {
                try {
                  const { data } = await github.rest.pulls.get({
                    owner,
                    repo,
                    pull_number: pr.number
                  });
                  
                  let mergeableStatus;
                  if (data.mergeable === true) {
                    mergeableStatus = 'MERGEABLE';
                  } else if (data.mergeable === false) {
                    mergeableStatus = 'CONFLICTING';
                  } else {
                    mergeableStatus = 'UNKNOWN';
                  }
                  
                  console.log(`PR #${pr.number} retry result: mergeable=${mergeableStatus}`);
                  
                  const result = processPR(pr, mergeableStatus);
                  if (result.conflict) {
                    conflictingPRs.push(result.data);
                    if (result.isTargetPR) break;
                  } else if (result.unknown) {
                    console.log(`PR #${pr.number} still has UNKNOWN status, will be checked on next run`);
                  }
                } catch (error) {
                  console.error(`Error retrying PR #${pr.number}: ${error.message}`);
                }
              }
            }
            
            if (manualPrNumber && conflictingPRs.length === 0) {
              console.log(`Warning: PR #${manualPrNumber} not found or has no conflicts`);
            }
            
            const MAX_PRS = 15;
            if (conflictingPRs.length > MAX_PRS) {
              console.log(`Warning: Found ${conflictingPRs.length} PRs with conflicts, limiting to ${MAX_PRS} for safety`);
              conflictingPRs.length = MAX_PRS;
            }
            
            console.log(`Found ${conflictingPRs.length} PRs with conflicts that need Devin sessions`);
            
            const fs = require('fs');
            fs.writeFileSync('/tmp/conflicting-prs.json', JSON.stringify(conflictingPRs));
            
            core.setOutput('has-conflicts', conflictingPRs.length > 0 ? 'true' : 'false');
            core.setOutput('conflict-count', conflictingPRs.length.toString());

      - name: Create Devin sessions for conflicting PRs
        if: steps.check-prs.outputs.has-conflicts == 'true'
        env:
          DEVIN_API_KEY: ${{ secrets.DEVIN_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const conflictingPRs = JSON.parse(fs.readFileSync('/tmp/conflicting-prs.json', 'utf8'));
            const { owner, repo } = context.repo;
            
            for (const pr of conflictingPRs) {
              console.log(`Creating Devin session for PR #${pr.number}: ${pr.title}${pr.is_fork ? ' (fork)' : ''}`);
              
              const forkInstructions = pr.is_fork ? `
            IMPORTANT: This PR is from a fork. The contributor has enabled "Allow edits from maintainers".
            - Clone the FORK repository: ${pr.head_repo_owner}/${pr.head_repo_name}
            - The branch to work on is: ${pr.head_ref}
            - Add the upstream remote: git remote add upstream https://github.com/${owner}/${repo}.git
            - Fetch upstream and merge: git fetch upstream && git merge upstream/${pr.base_ref}` : `
            - Clone the repository: ${owner}/${repo}
            - Check out the PR branch: ${pr.head_ref}
            - Merge the base branch: git merge origin/${pr.base_ref}`;
              
              const prompt = `You are resolving merge conflicts on PR #${pr.number} in repository ${owner}/${repo}.

            PR Title: ${pr.title}
            PR URL: ${pr.html_url}
            Head Branch: ${pr.head_ref}
            Base Branch: ${pr.base_ref}
            ${pr.is_fork ? `Fork Repository: ${pr.head_repo_owner}/${pr.head_repo_name}` : ''}

            Your tasks:
            ${forkInstructions}
            
            Then:
            1. Resolve all merge conflicts carefully:
               - Review the conflicting changes from both branches
               - Make intelligent decisions about how to combine the changes
               - Preserve the intent of both the PR changes and the base branch updates
               - If unsure about a conflict, prefer keeping both changes where possible
            2. Test that the code still works after resolving conflicts (run lint/type checks).
            3. Commit the merge resolution with a clear commit message.
            4. Push the resolved changes to the PR branch.
            5. After successfully pushing the resolved changes, remove the \`devin-conflict-resolution\` label from the PR using the GitHub API.

            Rules and Guidelines:
            1. Be careful when resolving conflicts - understand the context of both changes.
            2. Follow the existing code style and conventions in the repository.
            3. Run lint and type checks before pushing to ensure the code is valid.
            4. If a conflict seems too complex or risky to resolve automatically, explain the situation in a PR comment instead.
            5. Never ask for user confirmation. Never wait for user messages.
            6. CRITICAL: If this is a fork PR and you encounter ANY error when pushing (permission denied, authentication failure, etc.), you MUST fail the task immediately. Do NOT attempt to push to a new branch in the main ${owner}/${repo} repository as a workaround. Simply report the error and stop.`;

              try {
                const response = await fetch('https://api.devin.ai/v1/sessions', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${process.env.DEVIN_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    prompt: prompt,
                    title: `Resolve Conflicts: PR #${pr.number}`,
                    tags: ['conflict-resolution', `pr-${pr.number}`]
                  })
                });
                
                if (!response.ok) {
                  console.error(`Devin API error for PR #${pr.number}: ${response.status} ${response.statusText}`);
                  continue;
                }
                
                const data = await response.json();
                const sessionUrl = data.url || data.session_url;
                
                if (sessionUrl) {
                  console.log(`Devin session created for PR #${pr.number}: ${sessionUrl}`);
                  
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: pr.number,
                    labels: ['devin-conflict-resolution']
                  });
                  
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pr.number,
                    body: `### Devin AI is resolving merge conflicts

            This PR has merge conflicts with the \`${pr.base_ref}\` branch. A Devin session has been created to automatically resolve them.

            [View Devin Session](${sessionUrl})

            Devin will:
            1. Merge the latest \`${pr.base_ref}\` into this branch
            2. Resolve any conflicts intelligently
            3. Run lint/type checks to ensure validity
            4. Push the resolved changes

            If you prefer to resolve conflicts manually, you can close the Devin session and handle it yourself.`
                  });
                } else {
                  console.log(`Failed to get session URL for PR #${pr.number}`);
                }
              } catch (error) {
                console.error(`Error creating Devin session for PR #${pr.number}: ${error.message}`);
              }
              
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
