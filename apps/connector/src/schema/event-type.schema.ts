import type { PaginationQuery } from "@/types";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

import type { Prisma } from "@calcom/prisma/client";
import { PeriodType, SchedulingType } from "@calcom/prisma/client";

// REQUEST SCHEMAS
// Query schemas
export const getEventTypesQuerySchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(10),
  orderBy: z.enum(["id", "title", "slug", "length", "position"]).optional(),
  orderDir: z.enum(["asc", "desc"]).default("desc"),
  title: z.string().optional(),
  slug: z.string().optional(),
  hidden: z.coerce.boolean().optional(),
});

// Body schemas
export const createEventTypeBodySchema = z.object({
  title: z.string().min(4, "Title is required").max(255, "Title too long"),
  slug: z.string().min(4, "Slug is required").max(100, "Slug too long"),
  description: z.string().optional().nullable(),
  interfaceLanguage: z.string().optional().nullable(),
  position: z.number().int().default(0),
  locations: z.any().optional().nullable(),
  length: z.number().int().min(10, "Length must be at least 10 minutes").default(15),
  offsetStart: z.number().int().default(0),
  hidden: z.boolean().default(false),
  timeZone: z.string().optional().nullable(),
  periodType: z.nativeEnum(PeriodType).default(PeriodType.UNLIMITED),
  periodStartDate: z.coerce.date().optional().nullable(),
  periodEndDate: z.coerce.date().optional().nullable(),
  periodDays: z.number().int().optional().nullable(),
  periodCountCalendarDays: z.boolean().optional().nullable(),
  requiresConfirmation: z.boolean().default(false),
  requiresConfirmationWillBlockSlot: z.boolean().default(false),
  requiresConfirmationForFreeEmail: z.boolean().default(false),
  requiresBookerEmailVerification: z.boolean().default(false),
  recurringEvent: z.any().optional().nullable(),
  disableGuests: z.boolean().default(false),
  hideCalendarNotes: z.boolean().default(false),
  hideCalendarEventDetails: z.boolean().default(false),
  minimumBookingNotice: z.number().int().min(0).default(120),
  beforeEventBuffer: z.number().int().default(0),
  afterEventBuffer: z.number().int().default(0),
  seatsPerTimeSlot: z.number().int().optional().nullable(),
  onlyShowFirstAvailableSlot: z.boolean().default(false),
  disableCancelling: z.boolean().optional().nullable().default(false),
  disableRescheduling: z.boolean().optional().nullable().default(false),
  seatsShowAttendees: z.boolean().optional().nullable().default(false),
  seatsShowAvailabilityCount: z.boolean().optional().nullable().default(true),
  schedulingType: z.nativeEnum(SchedulingType).optional().nullable(),
  scheduleId: z.number().int().optional().nullable(),
  price: z.number().int().default(0),
  currency: z.string().default("usd"),
  slotInterval: z.number().int().optional().nullable(),
  metadata: z.any().optional().nullable(),
  successRedirectUrl: z.string().url().optional().nullable(),
  forwardParamsSuccessRedirect: z.boolean().optional().nullable().default(true),
  bookingLimits: z.any().optional().nullable(),
  durationLimits: z.any().optional().nullable(),
  isInstantEvent: z.boolean().default(false),
  instantMeetingExpiryTimeOffsetInSeconds: z.number().int().default(90),
  assignAllTeamMembers: z.boolean().default(false),
  assignRRMembersUsingSegment: z.boolean().default(false),
  rrSegmentQueryValue: z.any().optional().nullable(),
  useEventTypeDestinationCalendarEmail: z.boolean().default(false),
  isRRWeightsEnabled: z.boolean().default(false),
  maxLeadThreshold: z.number().int().optional().nullable(),
  includeNoShowInRRCalculation: z.boolean().default(false),
  allowReschedulingPastBookings: z.boolean().default(false),
  hideOrganizerEmail: z.boolean().default(false),
  maxActiveBookingsPerBooker: z.number().int().optional().nullable(),
  maxActiveBookingPerBookerOfferReschedule: z.boolean().default(false),
  customReplyToEmail: z.string().email().optional().nullable(),
  eventTypeColor: z.any().optional().nullable(),
  rescheduleWithSameRoundRobinHost: z.boolean().default(false),
  useBookerTimezone: z.boolean().default(false),
  restrictionScheduleId: z.number().int().optional().nullable(),
});

export const updateEventTypeBodySchema = createEventTypeBodySchema.partial();

// RESPONSE SCHEMAS
export const EventTypeResponseSchema = z.object({
  id: z.number(),
  title: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  interfaceLanguage: z.string().nullable(),
  position: z.number(),
  locations: z.any().nullable(),
  length: z.number(),
  offsetStart: z.number(),
  hidden: z.boolean(),
  userId: z.number().nullable(),
  teamId: z.number().nullable(),
  profileId: z.number().nullable(),
  timeZone: z.string().nullable(),
  periodType: z.string(),
  periodStartDate: z.date().nullable(),
  periodEndDate: z.date().nullable(),
  periodDays: z.number().nullable(),
  periodCountCalendarDays: z.boolean().nullable(),
  lockTimeZoneToggleOnBookingPage: z.boolean(),
  lockedTimeZone: z.string().nullable(),
  requiresConfirmation: z.boolean(),
  requiresConfirmationWillBlockSlot: z.boolean(),
  requiresConfirmationForFreeEmail: z.boolean(),
  requiresBookerEmailVerification: z.boolean(),
  recurringEvent: z.any().nullable(),
  disableGuests: z.boolean(),
  hideCalendarNotes: z.boolean(),
  hideCalendarEventDetails: z.boolean(),
  minimumBookingNotice: z.number(),
  beforeEventBuffer: z.number(),
  afterEventBuffer: z.number(),
  seatsPerTimeSlot: z.number().nullable(),
  onlyShowFirstAvailableSlot: z.boolean(),
  disableCancelling: z.boolean().nullable(),
  disableRescheduling: z.boolean().nullable(),
  seatsShowAttendees: z.boolean().nullable(),
  seatsShowAvailabilityCount: z.boolean().nullable(),
  schedulingType: z.string().nullable(),
  scheduleId: z.number().nullable(),
  price: z.number(),
  currency: z.string(),
  slotInterval: z.number().nullable(),
  metadata: z.any().nullable(),
  successRedirectUrl: z.string().nullable(),
  forwardParamsSuccessRedirect: z.boolean().nullable(),
  bookingLimits: z.any().nullable(),
  durationLimits: z.any().nullable(),
  isInstantEvent: z.boolean(),
  instantMeetingExpiryTimeOffsetInSeconds: z.number(),
  assignAllTeamMembers: z.boolean(),
  assignRRMembersUsingSegment: z.boolean(),
  rrSegmentQueryValue: z.any().nullable(),
  useEventTypeDestinationCalendarEmail: z.boolean(),
  isRRWeightsEnabled: z.boolean(),
  maxLeadThreshold: z.number().nullable(),
  includeNoShowInRRCalculation: z.boolean(),
  allowReschedulingPastBookings: z.boolean(),
  hideOrganizerEmail: z.boolean(),
  maxActiveBookingsPerBooker: z.number().nullable(),
  maxActiveBookingPerBookerOfferReschedule: z.boolean(),
  customReplyToEmail: z.string().nullable(),
  eventTypeColor: z.any().nullable(),
  rescheduleWithSameRoundRobinHost: z.boolean(),
  secondaryEmailId: z.number().nullable(),
  useBookerTimezone: z.boolean(),
  restrictionScheduleId: z.number().nullable(),
  createdDate: z.date().nullable().optional(),
  updatedDate: z.date().nullable().optional(),
});

export const EventTypeResponseJsonSchema = zodToJsonSchema(EventTypeResponseSchema);
export type EventTypeResponse = z.infer<typeof EventTypeResponseSchema>;

export type EventTypePaginationQuery = PaginationQuery<Prisma.EventTypeOrderByWithRelationInput>;
