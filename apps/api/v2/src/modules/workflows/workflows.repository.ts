import { PrismaReadService } from "@/modules/prisma/prisma-read.service";
import { PrismaWriteService } from "@/modules/prisma/prisma-write.service";
import {
  WorkflowActivationDto,
  WorkflowTriggerDto,
  WorkflowTriggerType,
  WorkflowTimeUnit,
  WorkflowStepDto,
  WorkflowMessageDto,
  RecipientType,
  StepAction,
  TemplateType,
} from "@/modules/workflows/inputs/create-workflow.input";
import { WorkflowOutput } from "@/modules/workflows/outputs/workflow.output";
import { Injectable, NotFoundException } from "@nestjs/common";

import { Workflow, WorkflowStep } from "@calcom/prisma/client";

type WorkflowType = Workflow & { activeOn: { eventTypeId: number }[]; steps: WorkflowStep[] };

@Injectable()
export class WorkflowRepository {
  constructor(
    // Use separate read/write Prisma clients/services
    private readonly dbRead: PrismaReadService,
    private readonly dbWrite: PrismaWriteService
  ) {}

  async getById(teamId: number, id: number): Promise<WorkflowOutput | null> {
    const workflow = await this.dbRead.prisma.workflow.findUnique({
      where: {
        id: id,
        teamId: teamId, // Ensure the workflow belongs to the correct team
      },
      include: {
        steps: true,
        activeOn: { select: { eventTypeId: true } },
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found for team ${teamId}`);
    }

    return this.toDto(workflow);
  }

  private toDto(workflow: WorkflowType): WorkflowOutput {
    const activation: WorkflowActivationDto = {
      isActiveOnAll: workflow.isActiveOnAll,
      // Map the IDs from the join table relation
      activeOnEventTypeIds: workflow.activeOn?.map((relation) => relation.eventTypeId) ?? [],
    };

    const trigger: WorkflowTriggerDto = {
      type: workflow.trigger as WorkflowTriggerType, // Assuming enum names match
      offset:
        workflow.time !== null && workflow.timeUnit !== null
          ? { value: workflow.time, unit: workflow.timeUnit as WorkflowTimeUnit } // Assuming enum names match
          : undefined,
    };

    const steps: WorkflowStepDto[] = workflow.steps.map((step) => {
      const message: WorkflowMessageDto = {
        subject: step.emailSubject ?? "",
        // Decide how to handle reminderBody -> text/html. Assuming text for simplicity.
        text: step.reminderBody ?? undefined,
        html: undefined, // Or store HTML if reminderBody contains it
      };

      // Mapping recipient back is complex - requires logic based on action/sendTo
      // This is a simplified example, likely needing refinement.
      let recipient: RecipientType;
      let verifiedEmailId: number | undefined;
      let verifiedPhoneId: number | undefined;

      // Basic reverse mapping logic (EXAMPLE ONLY - NEEDS YOUR ACTUAL LOGIC)
      switch (step.action as StepAction) {
        case StepAction.EMAIL_HOST:
          recipient = RecipientType.HOST;
          break;
        case StepAction.EMAIL_ATTENDEE:
          recipient = RecipientType.ATTENDEE;
          break;
        case StepAction.SMS_ATTENDEE:
          recipient = RecipientType.ATTENDEE;
          break;
        case StepAction.WHATSAPP_ATTENDEE:
          recipient = RecipientType.ATTENDEE;
          break;
        case StepAction.EMAIL_ADDRESS:
          recipient = RecipientType.EMAIL;
          // You'd need a way to get the ID back from 'sendTo' or another field
          // verifiedEmailId = tryParseInt(step.sendTo); // Placeholder
          break;
        case StepAction.SMS_NUMBER:
        case StepAction.WHATSAPP_NUMBER:
          recipient =
            step.action === StepAction.SMS_NUMBER ? RecipientType.PHONE_NUMBER : RecipientType.PHONE_NUMBER; // Or distinct types if needed
          // You'd need a way to get the ID back from 'sendTo' or another field
          // verifiedPhoneId = tryParseInt(step.sendTo); // Placeholder
          break;
        default:
          recipient = RecipientType.ATTENDEE; // Default guess
      }

      return {
        id: step.id, // Include the step ID generated by DB
        stepNumber: step.stepNumber,
        action: step.action as StepAction, // Assuming enum names match
        recipient: recipient, // Map based on action/sendTo (NEEDS REFINEMENT)
        verifiedEmailId: verifiedEmailId, // (NEEDS REFINEMENT)
        verifiedPhoneId: verifiedPhoneId, // (NEEDS REFINEMENT)
        template: step.template as TemplateType, // Assuming enum names match
        includeCalendarEvent: step.includeCalendarEvent,
        sender: step.sender ?? "Default Sender", // Provide default if null
        message: message,
      };
    });

    return {
      id: workflow.id, // Include workflow ID
      name: workflow.name,
      activation: activation,
      trigger: trigger,
      steps: steps,
    };
  }
}
